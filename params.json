{
  "name": "CloudLens",
  "tagline": "The CloudLens programming language",
  "body": "# The CloudLens Programming Language\r\n\r\n* [Installation](#installation)\r\n* [Use](#use)\r\n  * [Table](#table-processing) \r\n  * [Stream](#stream-processing)\r\n  * [Working with JSON Input Files](#working-with-json-input-files)\r\n  * [Zeppelin Notebook for CloudLens](#zeppelin-notebook-for-cloudlens)\r\n* [Tutorial](#tutorial)\r\n  * [A CloudLens Script](#a-cloudlens-script)\r\n  * [State Variables](#state-variables)\r\n  * [Blocks and Multiple Traversals](#blocks-and-multiple-traversals)\r\n  * [Hierarchical Structures and Lenses](#hierarchical-structures-and-lenses)\r\n  * [Lens Execution](#lens-execution)\r\n  \r\n  \r\n# Installation\r\n\r\nCloudLens requires Apache Maven (tested with version 3.3.1 and above)\r\nand Java 8.\r\n\r\nBefore building, export JAVA\\_HOME to point to a Java 8 JDK.\r\n\r\n```\r\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home\r\n```\r\n\r\nTo build, execute the following command in the `cloudlens` folder.\r\n\r\n```\r\n./build-notebook.sh\r\n```\r\n\r\nThis operation may take a few minutes.\r\n\r\nThere is no need to rebuild the notebook after each repository update.\r\nIf you already have a working version of the notebook, to update\r\nCloudLens, just execute the following command in the `cloudlens`\r\nfolder.\r\n\r\n```\r\n./build.sh\r\n```\r\n\r\n# Use\r\n\r\nThere are two execution modes: [table](#table-processing) and\r\n[stream](#stream-processing) processing.\r\n\r\n## Table Processing\r\n\r\nThis is the default execution mode.  CloudLens stores the entire log\r\nhistory. It is thus possible to re-stream from the begining of the log\r\nan arbitrary number of time.\r\n\r\nThis mode can be used for troubleshooting, for instance, to determine\r\nthe causes of a crash from a particular log file.\r\n\r\nTo run a lens file `file.lens` on the log file `file.log`, use the\r\nexecutable `cloudlens`:\r\n\r\n```\r\n./cloudlens -run file.lens -log file.log\r\n```\r\n\r\n## Stream Processing\r\n\r\nIn streaming mode, CloudLens does not store the log history.  Hence,\r\nexecuting a script requires much less memory, but it is impossible to\r\nre-stream from the begining of the log.\r\n\r\nThis mode can be used for monitoring running systems (with a\r\npotentially infinite log stream), to report alerting states. It can\r\nalso be useful for analysing huge log files without loading the entire\r\nfile.\r\n\r\nIf no log file is provided, CloudLens uses the standard input. It can thus\r\nbe plugged to a running system with a simple unix pipe.  For example,\r\nto run CloudLens on system.log:\r\n\r\n```\r\ntail -f /var/log/system.log | ./cloudlens -run file.lens\r\n```\r\n\r\nTo activate the streaming mode while providing a log file, use the\r\n`-stream` option:\r\n\r\n```\r\n ./cloudlens -stream -run file.lens -log file.log\r\n```\r\n\r\nIn both modes, it is also possible to load multiple log files and\r\nmultiple lens files:\r\n\r\n```\r\n./cloudlens -run lens1.lens lens2.lens lens3.lens -log log1.log log2.log\r\n```\r\n\r\nLog files are concatenated, and lens files are loaded in\r\nsequence.\r\n\r\n## Working with JSON Input Files\r\n\r\nCloudLens can handle JSON objects as input. This makes it convenient to read logs\r\nthat have been stored in popular log processing systems.\r\n\r\nIt is possible to load a JSON array instead of a file of row data.\r\nEach element of the array become one log entry.\r\nTo load a JSON array, on the Command Line:\r\n\r\n```\r\n./cloudlens -format json -run file.lens -log file.json\r\n```\r\n\r\nIt is also possible to load a JSON object and specify a path to an\r\narray inside this object. On the Command Line:\r\n\r\n```\r\n./cloudlens -format json -jsonpath path.to.array -run file.lens -log file.log\r\n```\r\n\r\n## Javascript Librairies\r\n\r\nOn the command line, option `-js` loads a JavaScript file before executing the script.\r\n```\r\n./cloudlens -js file.js -run file.lens -log file.log.\r\n```\r\n\r\n## Zeppelin Notebook for CloudLens\r\n\r\nCloudLens provides an extension of the Zeppelin notebook as its IDE.\r\nTo start or restart the notebook, execute the following command in the `cloudlens` folder:\r\n\r\n```\r\n./start-notebook.sh\r\n```\r\n\r\nConnect to [http://localhost:8080](http://localhost:8080) in a web browser to use the notebook.\r\n\r\nTo terminate the web server, execute the following command in the `cloudlens` folder:\r\n\r\n```\r\n./stop-notebook.sh\r\n```\r\nTo load a log file into the notebook, execute the following command:\r\n```\r\nsource(\"file:///path/to/file.log\")\r\n```\r\n\r\nIt is also possible to load JSON arrays (in case the log is stored as JSON) with the `json` option. \r\n```\r\nsource(“file:///path/to/file.log”, json)\r\n```\r\nTo specify a path to an array inside a JSON object:\r\n```\r\nsource(“file:///path/to/file.log”, json, path.to.array)\r\n```\r\n\r\nTo load JavaScript libraries in the notebook, use the function CL.loadjs inside a JavaScript block:\r\n```\r\n { CL.loadjs(\"file:///js/file.js\") }\r\n```\r\n\r\nAny of the CloudLens scripts below can be cut and pasted, and executed in the notebook.\r\n\r\n\r\n\r\n\r\n# Tutorial\r\n\r\nCloudLens is a *streaming* programming language. Programs are executed on streams of JSON object constructed from an input file.\r\nEach line of an input line becomes a JSON object with a unique field `message` that contains the line's text.\r\nWe call these objects the *entries* of the log.\r\n\r\nWe now illustrate the different functionalities of CloudLens with a log file produced by Travis.\r\nWhen a user modifies the source code of a project, Travis automatically starts a test suite to make sure that the new modifications do not cause a regression in the application that's being developed.\r\nWe use the file  `log.txt`, a report generated by Travis for the OpenWhisk (http://openWhisk.org) project. \r\nThe entire log file is located at the following address:\r\nhttps://s3.amazonaws.com/archive.travis-ci.org/jobs/144778470/log.txt\r\n\r\n\r\n## A CloudLens Script\r\n\r\nOur first CloudLens script extracts the name of failed tests from `log.txt`.\r\nThese tests appear in the following format:\r\n```\r\nname > description FAILED\r\nsystem.basic.WskBasicTests > Wsk Action CLI should reject\r\n  delete of action that does not exist FAILED\r\n```\r\n\r\nThe CloudLens script that can extract this information from `log.txt` and its result\r\nare shown below.\r\n\r\n```\r\nmatch { \"(?<failure>.*) > .* FAILED\" }\r\nstream (entry) when(entry.failure) {\r\n   print(\"FAILED:\", entry.failure);\r\n}\r\n```\r\nOutput:\r\n```\r\nFAILED: system.basic.WskBasicTests\r\nFAILED: packages.UtilsTests\r\n```\r\n\r\nThis script has two parts. For each log entry: a `match` section extract information,\r\nand a `stream` section executed some arbitrary JavaScript code.\r\n\r\nThe `match` section adds fields to entries by using groups in Java regular expressions.\r\nA capture group  `(?<ident>regex)` defines new fields\r\n`ident` that contain the text corresponding to the regular expression\r\n`regex` for each log entry.\r\nIn the previous script, the regular expression adds a field\r\n`failure` that contains the name of the test that has failed.\r\n\r\nThe `stream` section contains arbitrary JavaScript code in which\r\nvariable `entry` contains the current log entry being processed.\r\nThe condition `when (entry.failure)` ensures this code is executed\r\nonly for entries for which `failure` is defined.\r\nIf no condition is specified, a rudimentary dependency analysis ensures\r\nthat a `stream` section is executed only when all the fields on which\r\nit depends are defined in the entry being processed.\r\n\r\n\r\n## State Variables\r\n\r\nIt is possible to share state variables between the different sections, like the field\r\n`failure` in the previous example. It is also possible to share state between\r\ndifferent iterations of the same section.\r\n\r\nIn the  `log.txt` file the starts and ends of tests are specified in the following format:\r\n```\r\nStarting test *description* at *date*\r\nFinished test *description* at *date*\r\n```\r\nThe following script prints the description of tests that lasted more than 12 seconds.\r\n```\r\nvar dateFormat = \"# date:Date[yyyy-MM-dd' 'HH:mm:ss.SSS]\";\r\nmatch {\r\n    \"(?<start>Starting) test (?<desc>.*) at (?<date>.*)\" + dateFormat;\r\n    \"(?<end>Finished) test (?<desc>.*) at (?<date>.*)\" + dateFormat\r\n}\r\nvar start;\r\nstream (entry) when (entry.start) {\r\n    start = entry.date;\r\n}\r\nstream (entry) when (entry.end) {\r\n    entry.duration = entry.date - start;\r\n    if (entry.duration > 12000) {\r\n        print(entry.duration, \"\\t\", entry.desc);\r\n    }\r\n}\r\n```\r\nOutput:\r\n```\r\n13107    Actions CLI should error with a proper warning if the action exceeds its ...\r\n14282    Wsk Activation Console should show an activation log message for hello world\r\n15563    Wsk Activation Console should show repeated activations\r\n31496    Util Actions should extract first n elements of an array of strings using...\r\n```\r\n\r\nThe variable `dateFormat` specifies the shape of field `date` defined\r\nby the two regular expressions in the `match` section.\r\nThis format expresses a complete date in milliseconds.\r\n\r\nThe `start` variable, shared between the two `stream` sections, is updated\r\nevery time the start of a test is detected, that is when the `start` field is defined.\r\nAt the end of the test, when the `end` field is defines, we add a field\r\n `duration` containing the the time duration of the test.\r\nIf this time is greater than 12 seconds (12000ms), we print the description of the test\r\n`entry.desc`.\r\n\r\n\r\n## Blocks and Multiple Traversals\r\n\r\nBlocks allow executing an arbitrary JavaScript code only once at the beginning or at the end of the\r\nstream.\r\nThis construct is useful for e.g., initializing a set of variables, or printing the results of an execution.\r\nThe following script counts the number of tests that have failed.\r\n\r\n```\r\nvar failed = 0;\r\nmatch { \"(?<failure>.*) > .* FAILED\" }\r\nstream (entry) when (entry.failure) {\r\n    failed++;\r\n}\r\n{ print(failed, \"failed tests\"); }\r\n```\r\nOutput:\r\n```\r\n2 failed tests\r\n```\r\n\r\nAs a convention, we rewind the stream after a block.\r\nIt is therefore possible to iterate one or more times on the same stream.\r\nThe following script prints the description of tests that took more than 10%\r\nof the total time of testing.\r\n```\r\nvar dateFormat = \"# date:Date[yyyy-MM-dd' 'HH:mm:ss.SSS]\";\r\nmatch {\r\n    \"(?<start>Starting) test (?<desc>.*) at (?<date>.*)\" + dateFormat;\r\n    \"(?<end>Finished) test (?<desc>.*) at (?<date>.*)\" + dateFormat\r\n}\r\nvar start;\r\nstream (entry) when (entry.start) {\r\n    start = entry.date;\r\n}\r\nstream (entry) when (entry.end) {\r\n    entry.duration = entry.date - start;\r\n}\r\n\r\nvar totalTime = 0;\r\nstream (entry) when (entry.duration) {\r\n    totalTime += entry.duration;\r\n}\r\n{\r\n  print(\"Total Time:\", totalTime/1000, \"seconds\");\r\n}\r\nstream (entry) when (entry.duration) {\r\n    entry.prop = entry.duration*100 / totalTime;\r\n    if (entry.prop > 10) {\r\n        print(entry.prop.toFixed(2)+\"%\", entry.desc)\r\n    }\r\n}\r\n```\r\nOutput:\r\n```\r\nTotal Time: 226.309 seconds\r\n13.92% Util Actions should extract first n elements of an array of strings using ...\r\n```\r\n```\r\nWarning: time.lens line 29, implicit restart of stream log!\r\n```\r\nWhen a test has ended, we add the duration of this test `entry.duration` to the total test time\r\n`totalTime`.\r\nAt the end of the stream,  the block prints the total test time.\r\nWe can then traverse the stream again to compute the proportion of time spent by each test:\r\n`entry.duration / totalTime`.\r\n\r\nCloudLens warns the user that the stream has been rewound.\r\nThis signals to the user that all of the processed entries have been kept in memory during\r\nthe execution of the program to enable rewinding and traversing the stream again.\r\nMoreover, this warns the user that the CloudLens script cannot be used for monitoring (analyzing infinite logs).\r\n\r\nTo deactivate this warning, it is possible to rewind explicitly the stream by using the contruct\r\n`restart log` right after the block.\r\nIt is also possible to use this instruction in the absence of a block.\r\n\r\n## Hierarchical Structures and Lenses\r\n\r\n\r\nIt is sometimes useful to structure entries hierarchically. For\r\nexample, when a test fails, Travis prints the stack trace.  Even if\r\nthe stack trace appears on multiple consecutive lines, each line is\r\nonly one fragment of information.  The entire trace can therefore be\r\ngrouped into a single entry.  More generally, entries can span over\r\nmultiple lines.  In our example, we assume that a line starting with a\r\nspace is a fragment of the preceding entry.\r\n\r\n```\r\ngroup in messages {\r\n    \"^[^ ]\"\r\n}\r\n```\r\nA `group` section regroups several consecutive entries into a single one\r\ncontaining an array (named `messages` in the example).\r\nWe thereby transform the stream of JSON objects containing one log line each\r\ninto a stream of objects containing an array of objects.\r\nA new entry is initialized each time the regular expression associated with\r\nthe  `group` section is detected.\r\nIn this example, we start a new entry when we encounter a line that does not start with a space.\r\nEach entry therefore contains all the fragments associated with it, that is,\r\nall the following lines that start with a space.\r\n\r\nFor each failed test, we thereby construct an array containing the entire stack trace.\r\nThis trace contains a lot of information that is not useful (test libraries, external API, etc...).\r\nSuppose we wish to filter these traces to retain only the calls associated with the source code\r\nof OpenWhisk.\r\n\r\nThe following script defines a *lens*, meaning a function that executes a CloudLens script.\r\n```\r\nlens stackCleanup() {\r\n    match {\r\n        \"at .*\\((?<whisk>Wsk.*)\\)\";\r\n    }\r\n    stream (line) when (line.whisk) {\r\n        print('    at', line.whisk)\r\n    }\r\n}\r\n```\r\nWhen excecuted over an entire stack trace, the `stackCleanup` lens only prints the lines\r\nthat contain the string `Wsk`, which is included in all OpenWhisk class names.\r\n\r\nFor each failed test, the following CloudLens script prints a filtered stack trace.\r\n```\r\nmatch { \"(?<failure>.*) > .* FAILED\" }\r\ngroup in messages {\r\n    \"^[^ ]\"\r\n}\r\nlens stackCleanup() {\r\n    match {\r\n        \"at .*\\((?<whisk>Wsk.*)\\)\";\r\n    }\r\n    stream (line) when (line.whisk) {\r\n        print('    at', line.whisk)\r\n    }\r\n}\r\nstream (entry) {\r\n    if (entry.messages[0].failure !== undefined) {\r\n        print(\"FAILED\", entry.messages[0].failure);\r\n        stackCleanup(entry.messages)\r\n    }\r\n}\r\n```\r\nOutput:\r\n```\r\nFAILED system.basic.WskBasicTests\r\n    at WskBasicTests.scala:295\r\n    at WskBasicTests.scala:295\r\n    at WskBasicTests.scala:295\r\n    at WskBasicTests.scala:50\r\n    at WskBasicTests.scala:50\r\nFAILED packages.UtilsTests\r\n    at WskTestHelpers.scala:111\r\n    at WskTestHelpers.scala:65\r\n```\r\nIf a test has failed, the field `failure` of the first entry of the array `entry.messages` \r\nis defined.\r\nWhen a lens is called, an optional argument can be used to specify the stream of entries to process.\r\nBy default, lenses are executed on the current stream but this could also be an arbitrary JavaScript array.\r\nIn this example, we start by printing the name of the test, and then execute the lens \r\n`stackCleanup` on the array `entry.messages`.\r\nWe therefore print only the lines of the stack trace that correspond to OpenWhisk classes.\r\n\r\n\r\n###Lens Execution\r\n\r\nThere exist two ways to execute a lens.\r\nTo illustrate these two options, let's define two lenses \r\n`testFailed` and `testTime` based on examples above.\r\nThe first option, which is used in the previous example, is to call the corresponding functions in a\r\nJavaScript block.\r\n```\r\n{ testFailed(); testTime(); }\r\n```\r\nOutput:\r\n```\r\nFAILED: system.basic.WskBasicTests\r\nFAILED: packages.UtilsTests\r\n13107    Actions CLI should error with a proper warning if the action exceeds its ...\r\n14282    Wsk Activation Console should show an activation log message for hello world\r\n15563    Wsk Activation Console should show repeated activations\r\n31496    Util Actions should extract first n elements of an array of strings using...\r\n```\r\nThe two lenses are then executed in sequence.\r\nWe start by streaming over the entire log to extract the names of failed tests.\r\nThen we restream the entire log to print the description of tests that lasted more than 12 seconds.\r\n\r\nThe second option allows executing these two analyses concurrently while streaming over the log only once.\r\n```\r\nrun testFailed()\r\nrun testTime()\r\n```\r\nOutput:\r\n```\r\n13107    Actions CLI should error with a proper warning if the action exceeds its ...\r\nFAILED: system.basic.WskBasicTests\r\n14282    Wsk Activation Console should show an activation log message for hello world\r\n15563    Wsk Activation Console should show repeated activations\r\nFAILED: packages.UtilsTests\r\n31496    Util Actions should extract first n elements of an array of strings using...\r\n```\r\nFor each entry, we execute first `testFailed` and then `testTime`.\r\nCompared to the previous example the results are interleaved.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}